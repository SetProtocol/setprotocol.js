/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import { Contract, ContractTransaction, EventFilter, Signer } from "ethers";
import { Listener, Provider } from "ethers/providers";
import { Arrayish, BigNumber, BigNumberish, Interface } from "ethers/utils";
import {
  TransactionOverrides,
  TypedEventDescription,
  TypedFunctionDescription
} from ".";

interface VRFInterface extends Interface {
  functions: {
    verifyLinearCombinationWithGenerator: TypedFunctionDescription<{
      encode([c, p, s, lcWitness]: [
        BigNumberish,
        (BigNumberish)[],
        BigNumberish,
        string
      ]): string;
    }>;

    projectiveAdd: TypedFunctionDescription<{
      encode([x1, z1, x2, z2]: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    linearCombination: TypedFunctionDescription<{
      encode([c, p1, cp1Witness, s, p2, sp2Witness, zInv]: [
        BigNumberish,
        (BigNumberish)[],
        (BigNumberish)[],
        BigNumberish,
        (BigNumberish)[],
        (BigNumberish)[],
        BigNumberish
      ]): string;
    }>;

    projectiveSub: TypedFunctionDescription<{
      encode([x1, z1, x2, z2]: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    bigModExp: TypedFunctionDescription<{
      encode([base, exponent, modulus]: [
        BigNumberish,
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    affineECAdd: TypedFunctionDescription<{
      encode([p1, p2, invZ]: [
        (BigNumberish)[],
        (BigNumberish)[],
        BigNumberish
      ]): string;
    }>;

    verifyVRFProof: TypedFunctionDescription<{
      encode([
        pk,
        gamma,
        c,
        s,
        seed,
        uWitness,
        cGammaWitness,
        sHashWitness,
        zInv
      ]: [
        (BigNumberish)[],
        (BigNumberish)[],
        BigNumberish,
        BigNumberish,
        BigNumberish,
        string,
        (BigNumberish)[],
        (BigNumberish)[],
        BigNumberish
      ]): string;
    }>;

    MINUS_ONE: TypedFunctionDescription<{ encode([]: []): string }>;

    hashToCurve: TypedFunctionDescription<{
      encode([k, input]: [(BigNumberish)[], BigNumberish]): string;
    }>;

    zqHash: TypedFunctionDescription<{
      encode([q, x]: [BigNumberish, BigNumberish]): string;
    }>;

    WORD_LENGTH_BYTES: TypedFunctionDescription<{ encode([]: []): string }>;

    FIELD_SIZE: TypedFunctionDescription<{ encode([]: []): string }>;

    BOTTOM_160_BITS: TypedFunctionDescription<{ encode([]: []): string }>;

    ecmulVerify: TypedFunctionDescription<{
      encode([x, scalar, q]: [
        (BigNumberish)[],
        BigNumberish,
        (BigNumberish)[]
      ]): string;
    }>;

    isValidVRFOutput: TypedFunctionDescription<{
      encode([
        pk,
        gamma,
        c,
        s,
        seed,
        uWitness,
        cGammaWitness,
        sHashWitness,
        zInv,
        output
      ]: [
        (BigNumberish)[],
        (BigNumberish)[],
        BigNumberish,
        BigNumberish,
        BigNumberish,
        string,
        (BigNumberish)[],
        (BigNumberish)[],
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    projectiveDiv: TypedFunctionDescription<{
      encode([x1, z1, x2, z2]: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    projectiveMul: TypedFunctionDescription<{
      encode([x1, z1, x2, z2]: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    squareRoot: TypedFunctionDescription<{
      encode([x]: [BigNumberish]): string;
    }>;

    GROUP_ORDER: TypedFunctionDescription<{ encode([]: []): string }>;

    MULTIPLICATIVE_GROUP_ORDER: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    scalarFromCurve: TypedFunctionDescription<{
      encode([hash, pk, gamma, uWitness, v]: [
        (BigNumberish)[],
        (BigNumberish)[],
        (BigNumberish)[],
        string,
        (BigNumberish)[]
      ]): string;
    }>;

    ySquared: TypedFunctionDescription<{ encode([x]: [BigNumberish]): string }>;

    pointAddress: TypedFunctionDescription<{
      encode([point]: [(BigNumberish)[]]): string;
    }>;

    SQRT_POWER: TypedFunctionDescription<{ encode([]: []): string }>;

    projectiveECAdd: TypedFunctionDescription<{
      encode([x1, y1, x2, y2]: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ]): string;
    }>;
  };

  events: {};
}

export class VRF extends Contract {
  connect(signerOrProvider: Signer | Provider | string): VRF;
  attach(addressOrName: string): VRF;
  deployed(): Promise<VRF>;

  on(event: EventFilter | string, listener: Listener): VRF;
  once(event: EventFilter | string, listener: Listener): VRF;
  addListener(eventName: EventFilter | string, listener: Listener): VRF;
  removeAllListeners(eventName: EventFilter | string): VRF;
  removeListener(eventName: any, listener: Listener): VRF;

  interface: VRFInterface;

  functions: {
    verifyLinearCombinationWithGenerator(
      c: BigNumberish,
      p: (BigNumberish)[],
      s: BigNumberish,
      lcWitness: string
    ): Promise<boolean>;

    projectiveAdd(
      x1: BigNumberish,
      z1: BigNumberish,
      x2: BigNumberish,
      z2: BigNumberish
    ): Promise<{
      x3: BigNumber;
      z3: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    linearCombination(
      c: BigNumberish,
      p1: (BigNumberish)[],
      cp1Witness: (BigNumberish)[],
      s: BigNumberish,
      p2: (BigNumberish)[],
      sp2Witness: (BigNumberish)[],
      zInv: BigNumberish
    ): Promise<(BigNumber)[]>;

    projectiveSub(
      x1: BigNumberish,
      z1: BigNumberish,
      x2: BigNumberish,
      z2: BigNumberish
    ): Promise<{
      x3: BigNumber;
      z3: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    bigModExp(
      base: BigNumberish,
      exponent: BigNumberish,
      modulus: BigNumberish
    ): Promise<BigNumber>;

    affineECAdd(
      p1: (BigNumberish)[],
      p2: (BigNumberish)[],
      invZ: BigNumberish
    ): Promise<(BigNumber)[]>;

    verifyVRFProof(
      pk: (BigNumberish)[],
      gamma: (BigNumberish)[],
      c: BigNumberish,
      s: BigNumberish,
      seed: BigNumberish,
      uWitness: string,
      cGammaWitness: (BigNumberish)[],
      sHashWitness: (BigNumberish)[],
      zInv: BigNumberish
    ): Promise<boolean>;

    MINUS_ONE(): Promise<BigNumber>;

    hashToCurve(
      k: (BigNumberish)[],
      input: BigNumberish
    ): Promise<(BigNumber)[]>;

    zqHash(q: BigNumberish, x: BigNumberish): Promise<BigNumber>;

    WORD_LENGTH_BYTES(): Promise<BigNumber>;

    FIELD_SIZE(): Promise<BigNumber>;

    BOTTOM_160_BITS(): Promise<BigNumber>;

    ecmulVerify(
      x: (BigNumberish)[],
      scalar: BigNumberish,
      q: (BigNumberish)[]
    ): Promise<boolean>;

    isValidVRFOutput(
      pk: (BigNumberish)[],
      gamma: (BigNumberish)[],
      c: BigNumberish,
      s: BigNumberish,
      seed: BigNumberish,
      uWitness: string,
      cGammaWitness: (BigNumberish)[],
      sHashWitness: (BigNumberish)[],
      zInv: BigNumberish,
      output: BigNumberish
    ): Promise<boolean>;

    projectiveDiv(
      x1: BigNumberish,
      z1: BigNumberish,
      x2: BigNumberish,
      z2: BigNumberish
    ): Promise<{
      x3: BigNumber;
      z3: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    projectiveMul(
      x1: BigNumberish,
      z1: BigNumberish,
      x2: BigNumberish,
      z2: BigNumberish
    ): Promise<{
      x3: BigNumber;
      z3: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    squareRoot(x: BigNumberish): Promise<BigNumber>;

    GROUP_ORDER(): Promise<BigNumber>;

    MULTIPLICATIVE_GROUP_ORDER(): Promise<BigNumber>;

    scalarFromCurve(
      hash: (BigNumberish)[],
      pk: (BigNumberish)[],
      gamma: (BigNumberish)[],
      uWitness: string,
      v: (BigNumberish)[]
    ): Promise<BigNumber>;

    ySquared(x: BigNumberish): Promise<BigNumber>;

    pointAddress(point: (BigNumberish)[]): Promise<string>;

    SQRT_POWER(): Promise<BigNumber>;

    projectiveECAdd(
      x1: BigNumberish,
      y1: BigNumberish,
      x2: BigNumberish,
      y2: BigNumberish
    ): Promise<{
      x3: BigNumber;
      y3: BigNumber;
      z3: BigNumber;
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
    }>;
  };

  verifyLinearCombinationWithGenerator(
    c: BigNumberish,
    p: (BigNumberish)[],
    s: BigNumberish,
    lcWitness: string
  ): Promise<boolean>;

  projectiveAdd(
    x1: BigNumberish,
    z1: BigNumberish,
    x2: BigNumberish,
    z2: BigNumberish
  ): Promise<{
    x3: BigNumber;
    z3: BigNumber;
    0: BigNumber;
    1: BigNumber;
  }>;

  linearCombination(
    c: BigNumberish,
    p1: (BigNumberish)[],
    cp1Witness: (BigNumberish)[],
    s: BigNumberish,
    p2: (BigNumberish)[],
    sp2Witness: (BigNumberish)[],
    zInv: BigNumberish
  ): Promise<(BigNumber)[]>;

  projectiveSub(
    x1: BigNumberish,
    z1: BigNumberish,
    x2: BigNumberish,
    z2: BigNumberish
  ): Promise<{
    x3: BigNumber;
    z3: BigNumber;
    0: BigNumber;
    1: BigNumber;
  }>;

  bigModExp(
    base: BigNumberish,
    exponent: BigNumberish,
    modulus: BigNumberish
  ): Promise<BigNumber>;

  affineECAdd(
    p1: (BigNumberish)[],
    p2: (BigNumberish)[],
    invZ: BigNumberish
  ): Promise<(BigNumber)[]>;

  verifyVRFProof(
    pk: (BigNumberish)[],
    gamma: (BigNumberish)[],
    c: BigNumberish,
    s: BigNumberish,
    seed: BigNumberish,
    uWitness: string,
    cGammaWitness: (BigNumberish)[],
    sHashWitness: (BigNumberish)[],
    zInv: BigNumberish
  ): Promise<boolean>;

  MINUS_ONE(): Promise<BigNumber>;

  hashToCurve(k: (BigNumberish)[], input: BigNumberish): Promise<(BigNumber)[]>;

  zqHash(q: BigNumberish, x: BigNumberish): Promise<BigNumber>;

  WORD_LENGTH_BYTES(): Promise<BigNumber>;

  FIELD_SIZE(): Promise<BigNumber>;

  BOTTOM_160_BITS(): Promise<BigNumber>;

  ecmulVerify(
    x: (BigNumberish)[],
    scalar: BigNumberish,
    q: (BigNumberish)[]
  ): Promise<boolean>;

  isValidVRFOutput(
    pk: (BigNumberish)[],
    gamma: (BigNumberish)[],
    c: BigNumberish,
    s: BigNumberish,
    seed: BigNumberish,
    uWitness: string,
    cGammaWitness: (BigNumberish)[],
    sHashWitness: (BigNumberish)[],
    zInv: BigNumberish,
    output: BigNumberish
  ): Promise<boolean>;

  projectiveDiv(
    x1: BigNumberish,
    z1: BigNumberish,
    x2: BigNumberish,
    z2: BigNumberish
  ): Promise<{
    x3: BigNumber;
    z3: BigNumber;
    0: BigNumber;
    1: BigNumber;
  }>;

  projectiveMul(
    x1: BigNumberish,
    z1: BigNumberish,
    x2: BigNumberish,
    z2: BigNumberish
  ): Promise<{
    x3: BigNumber;
    z3: BigNumber;
    0: BigNumber;
    1: BigNumber;
  }>;

  squareRoot(x: BigNumberish): Promise<BigNumber>;

  GROUP_ORDER(): Promise<BigNumber>;

  MULTIPLICATIVE_GROUP_ORDER(): Promise<BigNumber>;

  scalarFromCurve(
    hash: (BigNumberish)[],
    pk: (BigNumberish)[],
    gamma: (BigNumberish)[],
    uWitness: string,
    v: (BigNumberish)[]
  ): Promise<BigNumber>;

  ySquared(x: BigNumberish): Promise<BigNumber>;

  pointAddress(point: (BigNumberish)[]): Promise<string>;

  SQRT_POWER(): Promise<BigNumber>;

  projectiveECAdd(
    x1: BigNumberish,
    y1: BigNumberish,
    x2: BigNumberish,
    y2: BigNumberish
  ): Promise<{
    x3: BigNumber;
    y3: BigNumber;
    z3: BigNumber;
    0: BigNumber;
    1: BigNumber;
    2: BigNumber;
  }>;

  filters: {};

  estimate: {
    verifyLinearCombinationWithGenerator(
      c: BigNumberish,
      p: (BigNumberish)[],
      s: BigNumberish,
      lcWitness: string
    ): Promise<BigNumber>;

    projectiveAdd(
      x1: BigNumberish,
      z1: BigNumberish,
      x2: BigNumberish,
      z2: BigNumberish
    ): Promise<BigNumber>;

    linearCombination(
      c: BigNumberish,
      p1: (BigNumberish)[],
      cp1Witness: (BigNumberish)[],
      s: BigNumberish,
      p2: (BigNumberish)[],
      sp2Witness: (BigNumberish)[],
      zInv: BigNumberish
    ): Promise<BigNumber>;

    projectiveSub(
      x1: BigNumberish,
      z1: BigNumberish,
      x2: BigNumberish,
      z2: BigNumberish
    ): Promise<BigNumber>;

    bigModExp(
      base: BigNumberish,
      exponent: BigNumberish,
      modulus: BigNumberish
    ): Promise<BigNumber>;

    affineECAdd(
      p1: (BigNumberish)[],
      p2: (BigNumberish)[],
      invZ: BigNumberish
    ): Promise<BigNumber>;

    verifyVRFProof(
      pk: (BigNumberish)[],
      gamma: (BigNumberish)[],
      c: BigNumberish,
      s: BigNumberish,
      seed: BigNumberish,
      uWitness: string,
      cGammaWitness: (BigNumberish)[],
      sHashWitness: (BigNumberish)[],
      zInv: BigNumberish
    ): Promise<BigNumber>;

    MINUS_ONE(): Promise<BigNumber>;

    hashToCurve(k: (BigNumberish)[], input: BigNumberish): Promise<BigNumber>;

    zqHash(q: BigNumberish, x: BigNumberish): Promise<BigNumber>;

    WORD_LENGTH_BYTES(): Promise<BigNumber>;

    FIELD_SIZE(): Promise<BigNumber>;

    BOTTOM_160_BITS(): Promise<BigNumber>;

    ecmulVerify(
      x: (BigNumberish)[],
      scalar: BigNumberish,
      q: (BigNumberish)[]
    ): Promise<BigNumber>;

    isValidVRFOutput(
      pk: (BigNumberish)[],
      gamma: (BigNumberish)[],
      c: BigNumberish,
      s: BigNumberish,
      seed: BigNumberish,
      uWitness: string,
      cGammaWitness: (BigNumberish)[],
      sHashWitness: (BigNumberish)[],
      zInv: BigNumberish,
      output: BigNumberish
    ): Promise<BigNumber>;

    projectiveDiv(
      x1: BigNumberish,
      z1: BigNumberish,
      x2: BigNumberish,
      z2: BigNumberish
    ): Promise<BigNumber>;

    projectiveMul(
      x1: BigNumberish,
      z1: BigNumberish,
      x2: BigNumberish,
      z2: BigNumberish
    ): Promise<BigNumber>;

    squareRoot(x: BigNumberish): Promise<BigNumber>;

    GROUP_ORDER(): Promise<BigNumber>;

    MULTIPLICATIVE_GROUP_ORDER(): Promise<BigNumber>;

    scalarFromCurve(
      hash: (BigNumberish)[],
      pk: (BigNumberish)[],
      gamma: (BigNumberish)[],
      uWitness: string,
      v: (BigNumberish)[]
    ): Promise<BigNumber>;

    ySquared(x: BigNumberish): Promise<BigNumber>;

    pointAddress(point: (BigNumberish)[]): Promise<BigNumber>;

    SQRT_POWER(): Promise<BigNumber>;

    projectiveECAdd(
      x1: BigNumberish,
      y1: BigNumberish,
      x2: BigNumberish,
      y2: BigNumberish
    ): Promise<BigNumber>;
  };
}
