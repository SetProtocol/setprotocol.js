/// <reference types="node" />
import Web3 from 'web3';
import { Order } from '@0xproject/types';
import { Address, Bytes, Constants, ECSig, ExchangeOrder, KyberTrade, Log, ZeroExSignedFillOrder } from './types';
import { BigNumber } from './bignumber';
import { Web3Utils } from './Web3Utils';
import { BN } from './bn';
import { Blockchain } from './blockchain';
export { BigNumber };
export { Blockchain };
export { BN };
export { Web3Utils };
export { BaseContract } from './baseContract';
export { Address, Bytes, Constants, ECSig, ExchangeIssuanceParams, ExchangeOrder, KyberTrade, Log, SolidityTypes, LinkedList, TimeSeriesFeedState, UInt, ZeroExSignedFillOrder, } from './types';
/**
 * The Utils class is an entry-point into the set-protocols-util.js library for reusable utility
 * methods that pertain to encoding, order generation, signing, etc.
 */
export declare class SetProtocolUtils {
    private web3;
    /**
     * Exposing commonly used non-mapping constants. Mapppings are defined separately,
     * see EXCHANGES and REBALANCING_STATE for examples. Constants that only apply to
     * development environments are defined as part of SetProtocolTestUtils
     */
    static CONSTANTS: Constants;
    /**
     * Enumeration of accepted exchange wrapper ids used as part of Exchange headers
     * { ZERO_EX: 1, KYBER: 2, TAKER_WALLET: 3 }
     */
    static EXCHANGES: any;
    /**
     * Enumeration of states of rebalancing token
     * { DEFAULT: 0, PROPOSAL: 1, REBALANCE: 2 }
     */
    static REBALANCING_STATE: any;
    /**
     * Generates a pseudo-random 256-bit salt
     *
     * @return  A pseudo-random 256-bit number that can be used as a salt
     */
    static generateSalt(): BigNumber;
    /**
     * Function for clarifying the additional call data parameters that need to be sent to Core when creating
     * a new rebalancing set token
     *
     * @param  managerAddress      Address of the manager to manage the rebalancing
     * @param  proposalPeriod      Time the participants of the Set can withdraw from a rebalance
     *                               once a new Set has been proposed
     * @param  rebalanceInterval   Time between when the manager can initiate another rebalance
     * @return                     String representing call data to send to Core contracts
     */
    static generateRebalancingSetTokenCallData(managerAddress: Address, proposalPeriod: BigNumber, rebalanceInterval: BigNumber): string;
    /**
     * Function for clarifying the additional call data parameters that need to be sent to Core when creating
     * a new rebalancing set token
     *
     * @param  managerAddress           Address of the manager to manage the rebalancing
     * @param  liquidatorAddress        Address of the contract that handles trade execution
     * @param  recipientAddress         Address of recipient of fees
     * @param  rebalanceInterval        Time between when the manager can initiate another rebalance
     * @param  lastRebalanceTimestamp   Customized time in seconds of the last rebalance
     * @param  entryFee                 Mint fee in scaled value (10e18 value)
     * @param  rebalanceFee             Rebalance fee in scaled value
     * @return                     String representing call data to send to Core contracts
     */
    static generateRebalancingSetTokenV2CallData(managerAddress: Address, liquidatorAddress: Address, feeRecipient: Address, rebalanceFeeCalculator: Address, rebalanceInterval: BigNumber, failRebalancePeriod: BigNumber, lastRebalanceTimestamp: BigNumber, entryFee: BigNumber, rebalanceFeeCalculatorCalldata: Buffer): string;
    /**
     * Function for clarifying the additional call data parameters that need to be sent to Core when creating
     * a new rebalancing set token v3
     *
     * @param  managerAddress           Address of the manager to manage the rebalancing
     * @param  liquidatorAddress        Address of liquidator that handles rebalancing
     * @param  recipientAddress         Address of recipient of fees
     * @param  rebalanceInterval        Time between when the manager can initiate another rebalance
     * @param  lastRebalanceTimestamp   Customized time in seconds of the last rebalance
     * @param  entryFee                 Mint fee in scaled value (10e18 value)
     * @param  feeCalculatorCalldata    Fee calculator in array of buffers
     * @return                          String representing call data to send to Core contracts
     */
    static generateRebalancingSetTokenV3CallData(managerAddress: Address, liquidatorAddress: Address, feeRecipient: Address, rebalanceFeeCalculator: Address, rebalanceInterval: BigNumber, failRebalancePeriod: BigNumber, lastRebalanceTimestamp: BigNumber, entryFee: BigNumber, feeCalculatorCalldata: Buffer[]): string;
    /**
     * Function for generating Buffer / calldata required for the FixedRebalanceFeeCalculator.
     *
     * @param  rebalanceFee             Rebalance fee in scaled value
     * @return                          Buffered data
     */
    static generateFixedFeeCalculatorCalldata(rebalanceFee: BigNumber): Buffer;
    /**
     * Function for generating hex string that can be parsed by performance fee calculator to set fee params.
     *
     * @param  profitPeriod                   Time allowed between profitFee collection
     * @param  highWatermarkResetPeriod       Time required to pass from last profitFee accrual before
     *                                        highWatermark is reset
     * @param  profitFeePercentage            Profit fee percentage
     * @param  streamingFeePercentage         Streaming fee percentage
     * @return                                String representing performance fee calc data
     */
    static generatePerformanceFeeCallData(profitPeriod: BigNumber, highWatermarkResetPeriod: BigNumber, profitFeePercentage: BigNumber, streamingFeePercentage: BigNumber): string;
    /**
     * Function for generating performance fee calculator buffer array that can be appended to other call data to
     * form inputs for RebalancingSetTokenV3.
     *
     * @param  profitPeriod                   Time allowed between profitFee collection
     * @param  highWatermarkResetPeriod       Time required to pass from last profitFee accrual before highWatermark
     *                                        is reset
     * @param  profitFeePercentage            Profit fee percentage
     * @param  streamingFeePercentage         Streaming fee percentage
     * @return                                Array of performance fee calc buffers that can be appended to
     *                                        other call data
     */
    static generatePerformanceFeeCallDataBuffer(profitPeriod: BigNumber, highWatermarkResetPeriod: BigNumber, profitFeePercentage: BigNumber, streamingFeePercentage: BigNumber): Buffer[];
    /**
     * Function for generating hex string that can be parsed by performance fee calculator to adjust fee params.
     *
     * @param  feeType                  Enumeration of fee being changed
     * @param  newFeePercentage         New fee percentage
     * @return                          String representing adjust fee data
     */
    static generateAdjustFeeCallData(feeType: BigNumber, newFeePercentage: BigNumber): string;
    /**
     * Generates hash for price feed update
     *
     * @param   price        Price feed update
     * @param   timestamp    Timestamp for price feed update in unix time
     * @param   identifier   Salt identifying the trading pair of the price feed
     * @return  Hash of price feed update as hex string
     */
    static hashPriceFeedHex(price: BigNumber, timestamp: BigNumber, identifier?: string): string;
    /**
     * Gets the length of a buffer's contents
     *
     * @param   buffer   A buffer of arbitray length
     * @return  Number of bytes in hex representation of the buffer
     */
    static numBytesFromBuffer(buffer: Buffer[]): BigNumber;
    /**
     * Gets the length of a hex string
     *
     * @param   hex   Hex string
     * @return  Number of bytes in hex representation of the hex
     */
    static numBytesFromHex(hex: string): BigNumber;
    /**
     * Generates a buffer for a primitive value padded to 32 bytes. Use for encoding addresses (string),
     * enum, etc. Use paddedBufferForBigNumber for token amounts that need to be expressed in high numbers
     *
     * @param   value   Any primitive value (string, number) to encode
     * @return  Primitive value represented as Buffer
     */
    static paddedBufferForPrimitive(value: any): Buffer;
    /**
     * Generates a buffer for a BigNumber padded to 32 bytes
     *
     * Used by various
     *
     * @param   number   BigNumber to encode
     * @return  BigNumber value represented as Buffer
     */
    static paddedBufferForBigNumber(number: BigNumber): Buffer;
    /**
     * Parses a signature and returns its elliptic curve signature
     *
     * Used by setProtocol.js in SignatureUtils
     *
     * @param   signature   Hex signature to parse
     * @return  An object containing the Elliptic curve signature parameters
     */
    static parseSignatureHexAsRSV(signature: string): any;
    /**
     * Returns the hex string representation of a string padded with '0x'
     *
     * Used by setProtocol.js in various wrappers to convert string to bytes to match transaction parameter type
     *
     * @param   input   A string primitive
     * @return  Hex of the string which can be used as a bytes32 transaction parameter
     */
    static stringToBytes(input: string): Bytes;
    /**
     * Determines if a liquidity source is a KyberTrade
     *
     * Used by setProtocol.js OrderAssertions
     *
     * @param   trade   A liquiduity fill source object
     * @return  Boolean for whether or not fill order is a KyberTrade
     */
    static isKyberTrade(trade: ExchangeOrder): boolean;
    /**
     * Determines if an order is a ZeroExSignedFillOrder
     *
     * Used by setProtocol.js OrderAssertions
     *
     * @param   order   A liquiduity fill source object
     * @return  Boolean for whether or not fill order is a ZeroExOrder
     */
    static isZeroExOrder(order: ExchangeOrder): boolean;
    /**
     * Encodes a ERC20 token address into a 0x ERC20 token asset data
     *
     * @param   tokenAddress   The ERC20 address to encode
     * @return  A string representing the encoded ERC20 asset details
     */
    static encodeAddressAsAssetData(tokenAddress: Address): string;
    /**
     * Decodes the ERC20 token asset data to get the original address
     *
     * Used by setProtocol.js OrderAssertions
     *
     * @param   assetData   A string representing the encoded ERC20 asset details
     * @return  Original token address after decoding
     */
    static extractAddressFromAssetData(assetData: string): string;
    /**
     * Initialize a Utils class
     *
     * @param web3   Web3 instance to use
     */
    constructor(web3?: Web3);
    /**
     * Generates a byte string representing serialized exchange orders across different exchanges
     *
     * For 0x orders, it sums the fillAmounts of all 0x order and uses the total as the makerTokenAmount
     * in the exchange header that goes in front of all 0x orders
     *
     * For Kyber trades,it sums the sourceTokenAmount all each kyber trades and uses the total as the makerTokenAmount
     * in the exchange header that goes in front of all Kyber trades
     *
     * @param  orders              Array of orders from various exchanges
     * @return                     Buffer with all exchange orders formatted and concatenated
     */
    generateSerializedOrders(orders: ExchangeOrder[]): Bytes;
    /**
     * Generates a ZeroExSignedFillOrder with signature that can be passed
     * into generateSerializedOrders to generate valid exchange orders data
     * Caller passes in the fillAmount
     *
     * @param   senderAddress           Address calling 0x Exchange contract
     * @param   makerAddress            Maker asset owner
     * @param   takerAddress            Taker assert owner
     * @param   makerFee                Fee accrused to maker
     * @param   takerFee                Fee accrued to taker
     * @param   makerAssetAmount        Amount of asset to exchange
     * @param   takerAssetAmount        Amount of asset to exchange for
     * @param   makerTokenAddress       Address of asset to exchange
     * @param   takerTokenAddress       Address of asset to exchange for
     * @param   salt                    Pseudo-random number acting as a salt
     * @param   exchangeAddress         0x Exchange contract address
     * @param   feeRecipientAddress     Address to send fee
     * @param   expirationTimeSeconds   Order expiration in unix timestamp
     * @param   fillAmount              The amount of the 0x order to fill
     * @return  Object conforming to ZeroExSignedFillOrder inteface
     */
    generateZeroExSignedFillOrder(senderAddress: Address, makerAddress: Address, takerAddress: Address, makerFee: BigNumber, takerFee: BigNumber, makerAssetAmount: BigNumber, takerAssetAmount: BigNumber, makerTokenAddress: Address, takerTokenAddress: Address, salt: BigNumber, exchangeAddress: Address, feeRecipientAddress: Address, expirationTimeSeconds: BigNumber, fillAmount: BigNumber): Promise<ZeroExSignedFillOrder>;
    /**
     * Signs a message and returns it's elliptic curve signature
     *
     * @param   message   Data to sign
     * @param   address   Address to sign with
     * @return  An object containing the Elliptic curve signature parameters
     */
    signMessage(message: string, address: Address, addPrefix?: boolean): Promise<ECSig>;
    /**
     * Convert an EC Signature into hex format
     *
     * @param   ecSig   EC Signature object
     * @return  Hex string representation of an ECDSA signature
     */
    convertSigToHex(ecSig: ECSig): string;
    /**
     * Adds correct signature '0x' and signs 0x order
     *
     * @param   order   Object conforming to 0x's Order inteface
     * @return  Hex string representation of 0x 0rder signature
     */
    signZeroExOrderAsync(order: Order): Promise<string>;
}
/**
 * The TestUtils class is an entry-point into the set-protocols-util.js library for reusable utility
 * methods that pertain to testing
 */
export declare class SetProtocolTestUtils {
    private web3;
    /**
     * Address of deployed KyberNetworkProxy contract on test rpc, loaded from snapshot
     */
    static KYBER_NETWORK_PROXY_ADDRESS: any;
    /**
     * Address of deployed token to use in Kyber swap on test rpc, loaded from snapshot on account[3]
     */
    static KYBER_RESERVE_SOURCE_TOKEN_ADDRESS: any;
    /**
     * Address of deployed token to receive in Kyber swap on test rpc, loaded from snapshot
     */
    static KYBER_RESERVE_DESTINATION_TOKEN_ADDRESS: any;
    /**
     * Address of deployed 0x exchange address contract on test rpc, loaded from snapshot
     */
    static ZERO_EX_EXCHANGE_ADDRESS: any;
    /**
     * Address of deployed 0x erc20 proxy contract on test rpc, loaded from snapshot
     */
    static ZERO_EX_ERC20_PROXY_ADDRESS: any;
    /**
     * Address of deployed 0x token on test rpc, loaded from snapshot
     */
    static ZERO_EX_TOKEN_ADDRESS: any;
    /**
     * Asserts that an array of logs is a subject of all of another set of logs, usually
     * all the logs of a particular transaction
     *
     * @param   actual     Formatted logs retrieved via the txHash. See getLogsFromTxHash
     * @param   expected   A manually generated array of logs for a particular transaction
     */
    static assertLogEquivalence(actual: Log[], expected: Log[]): void;
    /**
     * Converts an array of Buffers into Hex
     *
     * @param   bufferArray   Array of buffers
     * @return  Hex of array of buffers represented as Bytes (string)
     */
    static bufferArrayToHex(bufferArray: Buffer[]): Bytes;
    /**
     * Converts an array of Bytes (each prefixed 0x) into one byte array
     *
     * @param   bytes   Array of byte strings
     * @return  A single byte string representing the array of bytes
     */
    static concatBytes(bytes: Bytes[]): Bytes;
    /**
     * Generates an exchange order header represented as a buffer array.
     *
     * @param  exchangeId            Enum corresponding to exchange id, see constants.EXCHANGES
     * @param  orderCount            Number of exchange orders
     * @param  makerTokenAmount      Amount of tokens the maker is willing to pay
     * @param  totalOrderBodyLength  Length of order data buffer
     * @return                       Array containing all inputs as buffers
     */
    static generateExchangeOrderHeader(exchangeName: string, orderCount: number, totalOrderBodyLength: number): Buffer[];
    /**
     * Generates expiration timestamp that can be used as part of IssuanceOrder
     *
     * @param   minutes   Number of minutes from now
     * @return  Expiration timestamp represented as BigNumber
     */
    static generateTimestamp(minutes: number): BigNumber;
    /**
     * Generates a byte array with a valid 0x order that can be passed into ZeroExExchangeWrapper
     *
     * @param   order       Object conforming to 0x's Order inteface
     * @param   signature   Elliptic curve signature as hex string
     * @param   fillAmount  Amount of 0x order to fill
     * @return  Hex string representation of valid 0xExchangeWrapper order
     */
    static generateZeroExExchangeWrapperOrder(order: Order, signature: Bytes, fillAmount: BigNumber): Bytes;
    /**
     * Generates a 0x order. Use if exclusively generating the 0x order body. If generating
     * IssuanceOrder zeroExExchange Order interfaces, use generateZeroExSignedFillOrder
     *
     * @param   senderAddress           Address calling 0x Exchange contract
     * @param   makerAddress            Maker asset owner
     * @param   takerAddress            Taker assert owner
     * @param   makerFee                Fee accrused to maker
     * @param   takerFee                Fee accrued to taker
     * @param   makerAssetAmount        Amount of asset to exchange
     * @param   takerAssetAmount        Amount of asset to exchange for
     * @param   makerTokenAddress       Address of asset to exchange
     * @param   takerTokenAddress       Address of asset to exchange for
     * @param   salt                    Pseudo-random number acting as a salt
     * @param   exchangeAddress         0x Exchange contract address
     * @param   feeRecipientAddress     Address to send fee
     * @param   expirationTimeSeconds   Order expiration in unix timestamp
     * @return  Object conforming to 0x's Order inteface
     */
    static generateZeroExOrder(senderAddress: Address, makerAddress: Address, takerAddress: Address, makerFee: BigNumber, takerFee: BigNumber, makerAssetAmount: BigNumber, takerAssetAmount: BigNumber, makerTokenAddress: Address, takerTokenAddress: Address, salt: BigNumber, exchangeAddress: Address, feeRecipientAddress: Address, expirationTimeSeconds: BigNumber): Order;
    /**
     * Generates a hex string representing a single Kyber trade without the exchange header. Used for testing
     * KyberNetworkWrapper directly. For issuance order testing flows, use generateSerializedOrders which
     * includes the exchange header that core uses for dispatching the buffer to the correct wrapper
     *
     * @param  trade         An object conforming to KyberTrade to transform into buffer
     * @return               Hex string for single Kyber trade
     */
    static kyberTradeToBytes(trade: KyberTrade): Bytes;
    /**
     * Converts a 0x order into binary representation, often to get byte count
     *
     * @param   order   Object conforming to 0x's Order inteface
     * @return  Array of buffers representing the order
     */
    static zeroExOrderToBuffer(order: Order): Buffer[];
    /**
     * Generates a buffer with a valid 0x order that can be passed into ZeroExExchangeWrapper. Used to generate the
     * orders data separately from the header to test invalid values.
     *
     * @param   orders       ZeroExSignedFillOrder objects
     * @return  Buffer representation of valid 0xExchangeWrapper order
     */
    static zeroExSignedFillOrderToBuffer(order: ZeroExSignedFillOrder): Buffer[];
    /**
     * Initialize a TestUtils class
     * @param web3   Web3 instance to use
     */
    constructor(web3?: Web3);
    /**
     * Retrieves readable logs from a transaction hash
     *
     * @param   txHash   Transaction hash to retrieve logs from
     * @return  Array of logs presented as Log
     */
    getLogsFromTxHash(txHash: string): Promise<Log[]>;
}
